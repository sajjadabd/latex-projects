\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=black,  %choose some color if you want links to stand out
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=3
}


\lstdefinestyle{javaStyle}{
  backgroundcolor=\color{backcolour},   
  frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\lstset{style=mystyle}

\begin{document}

\tableofcontents

\newpage

\section{Types of Passing Arguments}

\subsection{Call-by-value}

In the call-by-value evaluation strategy, when a function is called the arguments passed to it are all evaluated beforehand, and copies of the values are placed into newly allocated memory. During execution of the function body, the formal parameters now refer to their associated copied values in this new memory. At the function’s conclusion this memory may simply be deallocated.

\subsection{Call-by-reference}

In the call-by-reference evaluation strategy, when a function is called it receives the memory locations of the arguments passed to it. Therefore, during execution
of the function, its formal parameters may refer to and modify local variables of the caller of the function. In this case, no extra memory need be allocated:
the formal parameters of the function simply use the same memory used by the passed arguments.


\subsection{Call-by-Name}

A call-by-name mechanism passes a code block to the function call and the code block is complied, executed and calculated the value.




\subsection{Advantages of using Call by value method}

\begin{itemize}
	\item The method doesn't change the original variable, so it is preserving data.
	\item Whenever a function is called it, never affect the actual contents of the actual arguments.
	\item Value of actual arguments passed to the formal arguments, so any changes made in the formal argument does not affect the real cases.
\end{itemize}


\subsection{Advantages of using Call by reference method}

\begin{itemize}
	\item The function can change the value of the argument, which is quite useful.
	\item It does not create duplicate data for holding only one value which helps you to save memory space.
	\item In this method, there is no copy of the argument made. Therefore it is processed very fast.
\end{itemize}


\subsection{Disadvantages of using Call by value method}

\begin{itemize}
	\item You can't directly change a variable in a function body.
	\item Sometime argument can be complex expressions
	\item There are two copies created for the same variable which is not memory efficient.
\end{itemize}


\subsection{Disadvantages of using Call by reference method}

\begin{itemize}
	\item A function taking in a reference need to make sure that the input is non-null. 
	\item A lifetime guarantee is a big issue with references. This is specifically dangerous when working with lambdas and multi-threaded programs.
\end{itemize}

\section{Parameter Passing Modes in C}

\begin{itemize}
	\item Call by value parameter passing only
	\item Objects can be modified in a function by passing pointers to the object to the function
	\item Arrays and pointers are exchangeble in C: an array is
automatically passed as a pointer to the array
\end{itemize}

\section{Parameter Passing Modes in Fortran}

\begin{itemize}
	\item Call by reference parameter passing only
\end{itemize}


\section{Parameter Passing Modes in Pascal}

\begin{itemize}
	\item Call by value and call by reference parameter passing
	\item Call by value is similar to C
	\item Call by reference is indicated by var parameters
\begin{lstlisting}[language=Pascal]
swap(var a:integer, var b:integer)
var t;
begin
t := a; a := b; b := t
end
\end{lstlisting}
\end{itemize}


\newpage

\section{Parameter Passing Modes in C++}

\begin{itemize}
	\item Call by value and call by reference parameter passing
	\item Call by value is similar to C
	\item Call by reference is indicated by using \& for formal parameters
\begin{lstlisting}[language=C]
swap(int &a, int &b)
{ 
	int t = a; 
	a = b; 
	b = t; 
}
\end{lstlisting}

	\item Large objects should be passed by reference instead of by value to increase efficiency
	\item Arrays are automatically passed by reference (like in C)
	\item To avoid objects to be modified when passed by reference, const parameters can be used
\begin{lstlisting}[language=C]
store_record_in_file(const huge_record &r)
{ 
	... 
}
\end{lstlisting}

\end{itemize}



\section{Parameter Passing Modes in Java}

\begin{itemize}
	\item Call by value and call by reference/sharing parameter passing
	\item Java adopts both value and reference models of variables
	\begin{itemize}
		\item Variables of built-in types are passed by value
		\item Class instances are passed by sharing
	\end{itemize}
\end{itemize}


\newpage


\section{Parameter Passing Modes in Ada}

\begin{itemize}
	\item Call by value, call by result, and call by value/result parameter passing
	\item Indicated by Ada’s in(by value), out(by result), and in out(by value/result) modes for formal parameters
\begin{lstlisting}[language=Ada]
procedure shift(a:out integer, b:in out integer,
c:in integer) is
begin
	a := b; b := c;
end shift;
\end{lstlisting}
	\item in mode parameters can be read but not written in the subroutine
	\item out mode parameters can be written but not read in the subroutine
	\item in out mode parameters can be read and written in the subroutine
\end{itemize}


\section{Parameter Passing Modes in Python}

Python uses a mechanism, which is known as "Call-by-Object", sometimes also called "Call by Object Reference" or "Call by Sharing".




\section{Parameter Passing Modes in COBOL}

The parameters can be passed between programs in two ways :

\begin{itemize}
	\item By Reference
	\item By Content
\end{itemize}


\newpage

\subsection{Call By Reference}

If the values of variables in the called program are modified, then their new values will reflect in the calling program. If ''BY'' clause is not specified, then variables are always passed by reference.

\begin{lstlisting}[language=Cobol]
CALL sub-prog-name USING variable-1, variable-2.
\end{lstlisting}

Following example is the MAIN calling program and UTIL is the called program .

Main Program :
\begin{lstlisting}[language=Cobol]
IDENTIFICATION DIVISION.
PROGRAM-ID. MAIN.

DATA DIVISION.
   WORKING-STORAGE SECTION.
   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.
   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.

PROCEDURE DIVISION.
   CALL 'UTIL' USING WS-STUDENT-ID, WS-STUDENT-NAME.
   DISPLAY 'Student Id : ' WS-STUDENT-ID
   DISPLAY 'Student Name : ' WS-STUDENT-NAME
STOP RUN.
\end{lstlisting}


Call [Util] Program :
\begin{lstlisting}[language=Cobol]
IDENTIFICATION DIVISION.
PROGRAM-ID. UTIL.

DATA DIVISION.
   LINKAGE SECTION.
   01 LS-STUDENT-ID PIC 9(4).
   01 LS-STUDENT-NAME PIC A(15).

PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.
   DISPLAY 'In Called Program'.
   MOVE 1111 TO LS-STUDENT-ID.
EXIT PROGRAM.
\end{lstlisting}

\newpage

\subsection{Call By Content}

If the values of variables in the called program are modified, then their new values will not reflect in the calling program.

\begin{lstlisting}[language=Cobol]
CALL sub-prog-name USING 
BY CONTENT variable-1, BY CONTENT variable-2.
\end{lstlisting}


Following example is the MAIN calling program and UTIL is the called program :

Main Program :
\begin{lstlisting}[language=Cobol]
IDENTIFICATION DIVISION.
PROGRAM-ID. MAIN.

DATA DIVISION.
   WORKING-STORAGE SECTION.
   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.
   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.

PROCEDURE DIVISION.
   CALL 'UTIL' USING BY CONTENT WS-STUDENT-ID, BY CONTENT WS-STUDENT-NAME.
   DISPLAY 'Student Id : ' WS-STUDENT-ID
   DISPLAY 'Student Name : ' WS-STUDENT-NAME
STOP RUN.
\end{lstlisting}


Call [Util] Program :
\begin{lstlisting}[language=Cobol]
IDENTIFICATION DIVISION.
PROGRAM-ID. UTIL.

DATA DIVISION.
   LINKAGE SECTION.
   01 LS-STUDENT-ID PIC 9(4).
   01 LS-STUDENT-NAME PIC A(15).

PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.
   DISPLAY 'In Called Program'.
   MOVE 1111 TO LS-STUDENT-ID.
EXIT PROGRAM.
\end{lstlisting}







\end{document}