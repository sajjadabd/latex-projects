\documentclass[12pt]{article}

\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{multirow}


\newcolumntype{C}{ >{\centering\arraybackslash} m{4cm} }
\newcolumntype{B}{ >{\centering\arraybackslash} m{5cm} }
\newcolumntype{E}{ >{\centering\arraybackslash} m{11cm} }
\newcolumntype{I}{ >{\centering\arraybackslash} m{12cm} }
\newcolumntype{D}{ >{\centering\arraybackslash} m{3cm} }
\newcolumntype{F}{ >{\centering\arraybackslash} m{1cm} }
\newcolumntype{G}{ >{\centering\arraybackslash} m{2cm} }
\newcolumntype{H}{ >{\centering\arraybackslash} m{8cm} }
\newcolumntype{K}{ >{\centering\arraybackslash} m{7cm} }
\newcolumntype{Y}{ >{\centering\arraybackslash} 
m{10cm} }


\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{patterns}
\usetikzlibrary{matrix,backgrounds}
\usetikzlibrary{arrows,shapes,trees}
\usetikzlibrary{chains,shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}

\tikzstyle{input}=[
        draw,
        trapezium,
        trapezium left angle=60,
        trapezium right angle=120,
        inner sep=10pt,
        fill=white!25
]
\tikzstyle{output}=[
        draw,
        trapezium,
        trapezium left angle=60,
        trapezium right angle=120,
        inner sep=10pt,
        fill=white!25
]
\tikzstyle{debutfin}=[ellipse,draw,text=black,inner sep=10pt]
\tikzstyle{instruct}=[rectangle,draw,fill=white!50,inner sep=10pt]
\tikzstyle{test}=[diamond, aspect=1,thick,
draw=black,fill=white!50,text=black]
\tikzstyle{es}=[rectangle,draw,rounded corners=4pt,fill=white!25,inner sep=10pt]
%styledesflèches
\tikzstyle{suite}=[->,>=stealth,thick,rounded corners=4pt]
%placementdesnœuds

\usepackage[most]{tcolorbox}

\tcbset{
    frame code={}
    center title,
    left=10pt,
    right=10pt,
    top=10pt,
    bottom=10pt,
    colback=gray!10,
    colframe=gray,
    width=\dimexpr\textwidth\relax,
    enlarge left by=0mm,
    boxsep=5pt,
    arc=0pt,outer arc=0pt,
}




\usepackage{amsmath, amssymb}
\usepackage{mathtools}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                               
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=3
}



\lstset{style=mystyle}


\usepackage[margin=1in,footskip=.25in]{geometry}

\usepackage{xepersian}
\settextfont[Scale=1]{Vazir}

\renewcommand{\baselinestretch}{1.3} 

\begin{document}

\noindent
به نظر شما هدف از ارائه ی درس طراحی الگوریتم ها در مقطع کارشناسی فناوری اطلاعات چیست ؟

\begin{tcolorbox}
برای اینکه بتوانیم مرتبه ی زمانی الگوریتم هایمان را محاسبه کنیم و سعی کنیم الگوریتم هایی بنویسیم که هزینه ی زمانی کمتری دارند .
\end{tcolorbox}

\vspace{30pt}

\noindent
در تولید یک محصول نرم افزاری محاسبه ی پیچیدگی زمانی و فضایی یکی از مهمترین متریک های محاسبه شده توسط مهندسین نرم افزار است .

\noindent
الف ) به نظر شما چرا پیچیدگی الگوریتم و نرم افزار را محاسبه می کنند ؟

\begin{tcolorbox}
تا قبل از اجرای عملی بر روی سخت افزار بتوانند تحلیل کنند که آیا این الگوریتم در مقادیر داده های بزرگ بر روی سخت افزارمان توان اجرا دارد یا خیر .
\end{tcolorbox}

\vspace{30pt}


\noindent
ب ) منظور از 
$f(n) = O(g(n))$
و
$f(n) = \Omega(g(n))$
و
$f(n) = \theta(g(n))$
چیست ؟

\begin{tcolorbox}
\lr{big-$O$ Notation}

عبارت
$g(n) \in O(f(n))$
یعنی برای تابع پیچیدگی مفروض 
$f(n)$
،
$O(f(n))$
به مجموعه ای از توابع اشاره دارد که برای آنها ثابت های 
\lr{c}
و
\lr{$n_{0}$}
وجود دارند ، بطوریکه برای همه ی 
$n \geq n_{0}$
داریم :

$$
g(n) \leq cf(n)
$$
\end{tcolorbox}





\begin{tcolorbox}
\lr{big-$\Omega$ Notation}

عبارت
$g(n) \in \Omega(f(n))$
یعنی برای تابع پیچیدگی مفروض 
$f(n)$
،
$\Omega(f(n))$
به مجموعه ای از توابع اشاره دارد که برای آنها ثابت های 
\lr{c}
و
\lr{$n_{0}$}
وجود دارند ، بطوریکه برای همه ی 
$n \geq n_{0}$
داریم :

$$
g(n) \geq cf(n)
$$
\end{tcolorbox}




\begin{tcolorbox}
\lr{$\theta$ Notation}

عبارت
$g(n) \in \theta(f(n))$
یعنی :

\begin{center}
$g(n) \in O(f(n))$

و

$g(n) \in \Omega(f(n))$
\end{center}
\end{tcolorbox}


\vspace{30pt}



\noindent
ج ) کدامیک از موارد زیر می تواند درست باشد .

\begin{align*}
\begin{rcases}
f(n) = O(g(n)) \\
f(n) = \theta(g(n))
\end{rcases} \Rightarrow
f(n) = \Omega(g(n)) \qquad {\Large \checkmark}
\end{align*}


\begin{align*}
\begin{rcases}
f(n) = \Omega(g(n)) \\
f(n) = \theta(g(n))
\end{rcases} \Rightarrow
f(n) = \Omega(g(n)) \qquad {\Large \checkmark}
\end{align*}




\begin{align*}
\begin{rcases}
f(n) = \theta(h(n)) \\
g(n) = \Omega(f(n))
\end{rcases} \Rightarrow
g(n) = \Omega(h(n)) \qquad {\Large \checkmark}
\end{align*}




\begin{align*}
\begin{rcases}
f(n) = \Omega(g(n)) \\
f(n) = O(g(n))
\end{rcases} \Rightarrow
f(n) = \theta(g(n)) \qquad {\Large \checkmark}
\end{align*}







\begin{align*}
\begin{rcases}
f(n) = \theta(g(n)) \\
g(n) = \Omega(f(n))
\end{rcases} \Rightarrow
f(n) = \theta(g(n)) \qquad {\Large \checkmark}
\end{align*}



\newpage



\noindent
تفاوت میان الگوریتم های از نوع 
\textbf{تقسیم و غلبه}
 و
\textbf{حریصانه}
 چیست ؟


\begin{tcolorbox}
\textbf{تقسیم و غلبه}

\noindent
 تقسیم مسئله به یک یا چند نمونه کوچکتر و سپس حل نمونه های کوچکتر و سپس در صورت نیاز ترکیب راه حل ها برای حل کل مسئله
\end{tcolorbox}



\begin{tcolorbox}
\textbf{حریصانه}


\noindent
الگوریتم حریصانه با انجام یک سری انتخاب ، که در جای خود بهینه است ، عمل کرده به امید اینکه یک حل بهینه کلی یافت شود .


\noindent
در روش حریصانه ، تقسیم به نمونه های کوچکتر صورت نمی پذیرد .

\noindent
الگوریتم حریصانه ، کار را با یک مجموعه ی تهی آغاز کرده و به ترتیب بهینه ترین عناصر را به مجموعه اضافه می کند تا به راه حل نهایی دست یابد .

\end{tcolorbox}



\vspace{30pt}


\newpage

\noindent
اگر الگوریتمی روی سیستمی با اندازه ورودی 10 به مدت 8 میلی ثانیه اجرا شود ، همین الگوریتم با اندازه ورودی 100 روی سیستمی دیگر با قدرت پردازشی و سرعت اجرایی نصف سیستم موجود در چه زمانی اجرا خواهد شد ( پیچیدگی این الگوریتم از مرتبه ی 
$n\log{(n)}$
می باشد )

\begin{tcolorbox}

\begin{align*}
10\log{10} \to 8 ms
\end{align*}

وقتی قدرت پردازنده نصف می شود پس زمان پردازش 2 برابر می شود بنابراین داریم :

\begin{align*}
10\log{10} \to 16 ms
\end{align*}


وقتی ورودی را 100 می دهیم داریم :
\begin{latin}
\begin{align*}
100\log{100} &= 100\log{10^{2}} \\
&= 2 \times 100 \log{10}  \\
&= 200 \log{10} \\
&= 20 \times 10 \log{10}  \\
&= 20 \times \underbrace{10\log{10}}_{\text{16 ms}} \\
&= 320 ms
\end{align*}
\end{latin}

\end{tcolorbox}








\newpage

\noindent
الگوریتم جستجوی دودویی را بیان کنید و مشخص کنید از کدام دسته از الگوریتم هاست و پیچیدگی آن چیست ؟

\vspace{30pt}

\begin{tcolorbox}
\noindent
الگوریتم جستجوی دودویی از دسته ی الگوریتم های تقسیم و غلبه است و مرتبه ی اجرایی آن
$O(\log{(n)})$
می باشد .
\end{tcolorbox}


\begin{latin}
\begin{lstlisting}[language=C++, caption=]
int BinarySearch(A,n,key) {
	l = 1;
	h = n;
	while(l <= h) {
		mid = (l+h)/2;
		if(key == A[mid]) {
			return mid;
		}
		if(key < A[mid]) {
			h = mid - 1;
		} else {
			l = mid + 1;
		}
	}
	return -1;
}
\end{lstlisting}
\end{latin}


\vspace{30pt}



\newpage

\noindent
فلوچارتی را رسم کنید که عددی را از ورودی دریافت کند و مشخص کند که زوج است یا خیر ؟


\vspace{30pt}



\begin{center}
\begin{tikzpicture}
\node[debutfin] (a) at (0,0) {شروع};
\node[input] (b) at (0,-2) { بخوان را $X$ };
\node[instruct] (c) at (0,-4) {$D \leftarrow X / 2$};
\node[instruct] (d) at (0,-6) {$R \leftarrow X - 2 \times D$};
\node[test] (test) at (0,-8) {$R = 0$};
\node[output] (e) at (2,-10) {است زوج $X$};
\node[output] (f) at (-2,-10) {است فرد $X$};
\node[debutfin] (g) at (0,-13) {پایان};
%Placementdesflèches
\draw[suite] (a) -- (b);
\draw[suite] (b) -- (c);
\draw[suite] (c) -- (d);
\draw[suite] (d) -- (test);
\draw[suite] (test) -| (e) node[near start,yshift=7pt]{بله};
\draw[suite] (test) -| (f) node[near start,yshift=7pt]{خیر};
\draw[suite] (e) |- (0,-11.5) -- (g);
\draw[suite] (f) |- (0,-11.5) -- (g);
\end{tikzpicture}
\end{center}



\vspace{30pt}

\newpage


\noindent
پیچیدگی موارد زیر را مشخص کنید ؟



\begin{latin}
\begin{center}
  \bgroup
  \def\arraystretch{1.5}%
  \begin{tabular}{ E  B  }
	\begin{lstlisting}[language=C++, caption=]
	z = 0;
	for(i=1;i<=n;i++) {
		for(j=1;j<=n;j+=2) {
			for(k=1;k<=n^2;n*=3) {
				z++;
			}
		}
	}
	\end{lstlisting}
     &  
	\begin{lstlisting}[language=C++, caption=]
	.
	n
	n * n/2
	n * n/2 * log(n)
	n * n/2 * log(n)
	.
	.
	.
	\end{lstlisting}
  \end{tabular}
  \egroup
\end{center}
\end{latin}


\begin{tcolorbox}
\Large
\begin{align*}
O(n^{2}\log{(n)})
\end{align*}
\end{tcolorbox}



\begin{latin}
\begin{center}
  \bgroup
  \def\arraystretch{1.5}%
  \begin{tabular}{ I  D  }
	\begin{lstlisting}[language=C++, caption=]
	F(n) {
		if( n <= 1 ) {
			return 1;
		} else {
			return F(n/2) + F(n/3) + F(n-1) + F(n-2);
		}
	}
	\end{lstlisting}
     &  
	\begin{lstlisting}[language=C++, caption=]
	.
	.
	.
	.
	.
	.
	.
	\end{lstlisting}
  \end{tabular}
  \egroup
\end{center}
\end{latin}


\begin{tcolorbox}
\begin{align*}
\begin{rcases}
F(n/2) &\to \log^{n}_{2} \quad \\
F(n/3) &\to \log^{n}_{3} \\
F(n-1) &\to n \\
F(n-2) &\to \frac{n}{2} \\
\end{rcases} \Rightarrow 
O(n)
\end{align*}
\end{tcolorbox}



\newpage


\noindent
فرض کنید تابع 
$g(x,y)$
به این صورت تعریف شده باشد که در مکان
$x$
به تعداد
$y$
علامت 
$*$
را چاپ کند . در این صورت :


\noindent
خروجی الگوریتم
\lr{\lstinline{F_Print(0,8,3)}}
چیست ؟


\begin{tcolorbox}
\begin{latin}
\begin{center}
\begin{tikzpicture}
\tikzstyle{level 1}=[sibling distance=6cm,level distance = 4cm]
\tikzstyle{level 2}=[sibling distance=3cm,level distance = 3cm]
\tikzstyle{level 3}=[sibling distance=1cm,level distance = 2cm]
\node (root0) {$F(0,8,3)$}
child {node (root12) {$F(0,4,2)$}
	child {node (root24) {$F(0,2,1)$}
	}
	child {node (root23) {$F(2,4,1)$}
	}
}
child {node (root11)  {$F(4,8,2)$}
	child {node (root22) {$F(4,6,1)$}
	}
	child {node (root21) {$F(6,8,1)$}
	}	
};
\node (one0) at ($(root0)+(1.2,-0.5)$) {$g(4,3)$};
\node (one11) at ($(root11)+(1,-0.5)$) {$g(6,2)$};
\node (one12) at ($(root12)+(1,-0.5)$) {$g(2,2)$};
\node (one21) at ($(root21)+(1,-0.5)$) {$g(7,1)$};
\node (one22) at ($(root22)+(1,-0.5)$) {$g(5,1)$};
\node (one23) at ($(root23)+(1,-0.5)$) {$g(3,1)$};
\node (one24) at ($(root24)+(1,-0.5)$) {$g(1,1)$};
%\node (one0) at (7,0) {1};
%\node (one1) at (7,-1) {1};
%\node (one2) at (7,-2) {1};
%\node (one3) at (7,-3) {1};
%\draw[dashed] (root0) -- (one0);
%\draw[dashed] (root1) -- (one1);
%\draw[dashed] (root2) -- (one2);
%\draw[dashed] (root3) -- (one3);
\end{tikzpicture}
\end{center}
\end{latin}
\end{tcolorbox}






\noindent
پیچیدگی زمانی این الگوریتم را محاسبه کنید ؟


\begin{latin}
\begin{center}
  \bgroup
  \def\arraystretch{1.5}%
  \begin{tabular}{ E  D  }
	\begin{lstlisting}[language=C++, caption=]
	F_Print(int a,int b,int c) {
		int m = (a+b)/2 ;
		if(c > 0) {
			g(m,c);
			F_Print(a,m,c-1);
			F_Print(m,b,c-1);
		}
	}
	\end{lstlisting}
     &  
	\begin{lstlisting}[language=C++, caption=]
	T(c)
	.
	.
	c
	T(c-1)
	T(c-1)
	.
	.
	\end{lstlisting}
  \end{tabular}
  \egroup
\end{center}
\end{latin}




\begin{align*}
T(c) = 2 \: T(c-1) + c
\end{align*}




\begin{align*}
\begin{rcases}
\begin{tikzpicture}
\tikzstyle{level 1}=[sibling distance=6cm,level distance = 4cm]
\tikzstyle{level 2}=[sibling distance=3cm,level distance = 3cm]
\tikzstyle{level 3}=[sibling distance=1cm,level distance = 2cm]
\node (root0) {$T(c)$}
child {node {$T(c-1)$}
	child {node {$T(c-2)$}
		child {node {$\vdots$}}
		child {node {$\vdots$}}
	}
	child {node {$T(c-2)$}
		child {node {$\vdots$}}
		child {node {$\vdots$}}
	}
}
child {node (root1)  {$T(c-1)$}
	child {node {$T(c-2)$}
		child {node {$\vdots$}}
		child {node {$\vdots$}}
	}
	child {node (root2) {$T(c-2)$}
		child {node {$\vdots$}}
		child {node (root3) {$\vdots$}}
	}	
};
\node (one0) at ($(root0)+(8,0)$) {$c$};
\node (one1) at ($(root1)+(5,0)$) {$2c - M$};
\node (one2) at ($(root2)+(3.5,0)$) {$4c - M'$};
\node (one3) at ($(root3)+(3,0)$) {$2^{c}c - M''$};
%\node (one0) at (7,0) {1};
%\node (one1) at (7,-1) {1};
%\node (one2) at (7,-2) {1};
%\node (one3) at (7,-3) {1};
\draw[dashed] (root0) -- (one0);
\draw[dashed] (root1) -- (one1);
\draw[dashed] (root2) -- (one2);
\draw[dashed] (root3) -- (one3);
\end{tikzpicture}
\end{rcases}
\:\:
c
\end{align*}


\begin{align*}
c + 2c + 4c + \dots + 2^{c}c - M &= c [ 1 + 2 + 4 + \dots + 2^{c} ] \\
&= c [ 1 + 2 + 2^{2} + 2^{3} + \dots + 2^{c} ] \\
&= c [ 2^{c+1} - 1] \\
&= c 2^{c+1} - c \\
&\Rightarrow \colorbox{gray!10}{\parbox{90pt}{
    $$f(n)  = O(c2^{c}) $$
    }}
\end{align*}






\begin{latin}
\begin{align*}
T(c) &= 2 \: T(c-1) + c \\
T(c-1) &= 2 T(c-2) + c - 1 \\
\text{substitute}& \\
\Rightarrow T(c) &= 2 [ 2 T(c-2) + c - 1 ] + c \\
\Rightarrow T(c) &= 2^{2} T(c-2) + 2c - 2 + c \\
T(c-2) &= 2 T(c-3) + c - 2 \\
\Rightarrow T(c) &= 2^{2} [ 2 T(c-3) + c - 2 ] +  2c - 2 + c \\
\Rightarrow T(c) &= 2^{3} T(c-3) + 2^{2}c - 2^{3} + 2c - 2 + c \\
\Rightarrow T(c) &= 2^{3} T(c-3) + 2^{2}c + 2c + c - 2^{3}  - 2  \\
\text{continue for k times}& \\
\Rightarrow T(c) &= 2^{k} T(c-k) + \underbrace{2^{k-1}c +  \dots + 2^{2}c + 2c + c}_{\text{k times}}  + M \\
\Rightarrow T(c) &= 2^{k} T(c-k) + c[\underbrace{2^{k-1} +  \dots + 2^{2} + 2 + 1]}_{\text{k times}}  + M \\
\Rightarrow T(c) &= 2^{k} T(c-k) + c[2^{k} - 1] \\
\Rightarrow T(c) &= 2^{k} T(c-k) + c2^{k} - c \\
\end{align*}
\end{latin}


\begin{latin}
\begin{align*}
c - k = 0& \\
T(c) &= 2^{c} T(c-c) + c2^{c} - c \\
T(c) &= 2^{c} T(0) + c2^{c} - c \\
T(c) &= 2^{c} + c2^{c} - c \\
&\Rightarrow f(n) = O(c2^{c})
\end{align*}
\end{latin}



\end{document}